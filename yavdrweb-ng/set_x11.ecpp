<%pre>
#include <stdlib.h>
#include <string>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <ctype.h>

extern "C" {
#include <yavdr/db-utils/dbset.h>
#include <yavdr/db-utils/dbremove.h>
};

#include <yavdr/common.h>
#include <math.h>

namespace X11 {
	extern "C" {
#include <X11/Xlib.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include <X11/extensions/Xrandr.h>
#include <X11/extensions/Xrender.h>	/* we share subpixel information */
	}
}

using namespace std;
</%pre><& authenticate ><%args>
x11_graphtft = "0";
x11_dualhead = "0";
deinterlacer_hd = "";
deinterlacer_sd = "";
primary = "";
secondary = "";

// to be prepared
display;
string index[];
</%args><%shared>
void Tokenize(const string& str,
		vector<string>& tokens,
		const string& delimiters = " ")
{
	tokens.clear();
	// Skip delimiters at beginning.
	string::size_type lastPos = str.find_first_not_of(delimiters, 0);
	// Find first "non-delimiter".
	string::size_type pos = str.find_first_of(delimiters, lastPos);

	while (string::npos != pos || string::npos != lastPos)
	{
		// Found a token, add it to the vector.
		tokens.push_back(str.substr(lastPos, pos - lastPos));
		// Skip delimiters.  Note the "not_of"
		lastPos = str.find_first_not_of(delimiters, pos);
		// Find next "non-delimiter"
		pos = str.find_first_of(delimiters, lastPos);
	}
}

bool writeDisplayToHDF(int id, string display, string resolution, std::vector<string> modes, string defaultfreq, /*string defaultrate,*/string vpix, string vpiy, string vpox, string vpoy, string vpopx, string vpopy) {
	if (modes.size() > 0) {
		int err = dbset("system.x11.display.%i.device=%s" , id, display.c_str());
		err = dbset("system.x11.display.%i.resolution=%s" , id, resolution.c_str());
		sort(modes.begin(), modes.end());
		for(int i=0; i < modes.size(); i++) {
			err = dbset("system.x11.display.%i.rates.%i=%s", id, i, modes[i].c_str());
		}
		err = dbset("system.x11.display.%i.defaultrate=%s", id, defaultfreq.c_str());
		//err = dbset("system.x11.display.%i.rate=%s", id, defaultrate.c_str());
		err = dbset("system.x11.display.%i.viewport.in.x=%s", id, vpix.c_str());
		err = dbset("system.x11.display.%i.viewport.in.y=%s", id, vpiy.c_str());
		err = dbset("system.x11.display.%i.viewport.out.x=%s", id, vpox.c_str());
		err = dbset("system.x11.display.%i.viewport.out.y=%s", id, vpoy.c_str());
		err = dbset("system.x11.display.%i.viewport.out.plusx=%s", id, vpopx.c_str());
		err = dbset("system.x11.display.%i.viewport.out.plusy=%s", id, vpopy.c_str());

		return true;
	}
	return false;
}

void cleanDisplayInHDF(int id) {
	char buffer[100];
	sprintf(buffer, "system.x11.display.%i", id);
	int err = dbremove(buffer);
}

inline std::string trim_right(const std::string &source , const std::string& t = " ")
{
	std::string str = source;
	return str.erase( str.find_last_not_of(t) + 1);
}

inline std::string trim_left( const std::string& source, const std::string& t = " ")
{
	std::string str = source;
	return str.erase(0 , source.find_first_not_of(t) );
}

inline std::string trim(const std::string& source, const std::string& t = " ")
{
	std::string str = source;
	return trim_left( trim_right( str , t) , t );
}

</%shared><%cpp>
string success = "false";
string msg = "Unspecified error.";

int err;

err = dbset("vdr.deinterlacer.hd.type=%s", deinterlacer_hd.c_str());
err = dbset("vdr.deinterlacer.sd.type=%s", deinterlacer_sd.c_str());

// Query PCI-Device
X11::Display *dpy = X11::XOpenDisplay((display == ""?NULL:display.c_str()));

if (dpy) {
	int event_base, error_base;
	int major, minor;

	bool has_1_2, has_1_3;

	int screen = (((X11::_XPrivDisplay)dpy)->default_screen);
	X11::Window root = (((dpy)->screens[(screen)]).root);

	if (X11::XRRQueryExtension (dpy, &event_base, &error_base) &&
			X11::XRRQueryVersion (dpy, &major, &minor))
	{
		if (major > 1 || (major == 1 && minor >= 2)) {
			has_1_2 = true;
		}
		if (major > 1 || (major == 1 && minor >= 3)) {
			has_1_3 = true;
		}
		string defaultrate0 = "";
		string defaultrate1 = "";
		string defaultrate2 = "";

		err = dbremove("system.hardware.nvidia.0");
		err = dbremove("system.hardware.nvidia.1");

		/*		tnt::QueryParams q;
		 if (request.method() == "POST")
		 q.parse_url(request.bodyStr());
		 else
		 q.parse_url(request.qparams());
		 */
		tnt::QueryParams q = request.getQueryParams();
		printf("%lu: %s %s\n", q.paramcount("freq4"), q.param("freq4", 0).c_str(), q.param("freq4", 1).c_str());

		if (x11_dualhead != "1") {
			err = dbset("system.x11.dualhead.enabled=0");
			err = dbset("vdr.plugin.graphtft.enabled=0");

			cleanDisplayInHDF(0);
			string index = q.param("primary");
			std::vector<string> modes(q.paramcount("freq" + index));
			for(int j = 0; j < q.paramcount("freq" + index); j++) {
				modes[j] = q.param("freq" + index, j);
			}
			if (q.paramcount("freq" + index) > 0 && primary == q.param("display" + index)) {
				writeDisplayToHDF(0,
						q.param("display" + index),
						q.param("modeline" + index),
						modes,
						q.param("defaultfreq" + index),
						//q.param("defaultrate" + index),
						q.param("viewportinx" + index),
						q.param("viewportiny" + index),
						q.param("viewportoutx" + index),
						q.param("viewportouty" + index),
						q.param("viewportoutplusx" + index),
						q.param("viewportoutplusy" + index));
			}
			cleanDisplayInHDF(1);
		}
		else
		{
			err = dbset("system.x11.dualhead.enabled=1");
			err = dbset("vdr.plugin.graphtft.enabled=%s", (x11_graphtft=="1"?"1":"0"));

			cleanDisplayInHDF(0);
			string index = q.param("primary");

			if (q.param("modeline" + index) == "disabled") {
				err = dbset("system.x11.dualhead.enabled=0");
				err = dbset("vdr.plugin.graphtft.enabled=0");
			} else {
				std::vector<string> modes(q.paramcount("freq" + index));
				for(int j = 0; j < q.paramcount("freq" + index); j++) {
					modes[j] = q.param("freq" + index, j);
				}
				if (q.paramcount("freq" + index) > 0 && primary == q.param("display" + index)) {
					writeDisplayToHDF(0,
							q.param("display" + index),
							q.param("modeline" + index),
							modes,
							q.param("defaultfreq" + index),
							//q.param("defaultrate" + index),
							q.param("viewportinx" + index),
							q.param("viewportiny" + index),
							q.param("viewportoutx" + index),
							q.param("viewportouty" + index),
							q.param("viewportoutplusx" + index),
							q.param("viewportoutplusy" + index));
				}
			}

			cleanDisplayInHDF(1);
			index = q.param("secondary");
			if ((primary != "" && secondary == primary) || q.param("modeline" + index) == "disabled") {
				err = dbset("system.x11.dualhead.enabled=0");
				err = dbset("vdr.plugin.graphtft.enabled=0");
			} else {
				std::vector<string> modes(q.paramcount("freq" + index));
				for(int j = 0; j < q.paramcount("freq" + index); j++) {
					modes[j] = q.param("freq" + index, j);
				}
				if (q.paramcount("freq" + index) > 0 && primary == q.param("display" + index)) {
					writeDisplayToHDF(0,
							q.param("display" + index),
							q.param("modeline" + index),
							modes,
							q.param("defaultfreq" + index),
							//q.param("defaultrate" + index),
							q.param("viewportinx" + index),
							q.param("viewportiny" + index),
							q.param("viewportoutx" + index),
							q.param("viewportouty" + index),
							q.param("viewportoutplusx" + index),
							q.param("viewportoutplusy" + index));
				}
			}
		}

	}

	XCloseDisplay(dpy);
}
if (err) {
	msg = "Error on database operation";
}
else {
	int ret = system("/usr/bin/signal-event display-state-change");
	success = "true";
	msg = "OK. signal-event display-state-change";
}
</%cpp> {
	success: <$success$>
	/*    errors: {
	 receiver_id: "<$msg$>"
	 }
	 */
}
