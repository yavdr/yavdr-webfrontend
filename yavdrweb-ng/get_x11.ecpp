<%pre>
/* 
 * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
 * Copyright © 2002 Hewlett Packard Company, Inc.
 * Copyright © 2006 Intel Corporation
 * Copyright © 2012 yaVDR Project
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Thanks to Jim Gettys who wrote most of the client side code,
 * and part of the server code for randr.
 * 
 * Thanks to XRandR project. This code based mostly on it.
 */

#include <algorithm>
#include <string>
#include <sstream>
#include <ctype.h>
#include <yavdr/common.h>
#include <jsoncpp/json.hpp>
#include <ClearSilver.h>
#include <math.h>

namespace X11 {
	extern "C" {
#include <X11/Xlib.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include <X11/extensions/Xrandr.h>
#include <X11/extensions/Xrender.h>	/* we share subpixel information */
	}
}

using namespace std;
</%pre><& authenticate ><%args>
display;
</%args><%shared>

inline std::string format(const char* fmt, ...) {
	int size = 512;
	char* buffer = 0;
	buffer = new char[size];
	va_list vl;
	va_start(vl,fmt);
	int nsize = vsnprintf(buffer,size,fmt,vl);
	if(size<=nsize) { //fail delete buffer and try again
		delete buffer; buffer = 0;
		buffer = new char[nsize+1];//+1 for /0
		nsize = vsnprintf(buffer,size,fmt,vl);
	}
	std::string ret(buffer);
	va_end(vl);
	delete buffer;
	return ret;
}

static const char *connection[3] = {
	"connected",
	"disconnected",
	"unknown connection"};

static const char *direction[5] = {
	"normal",
	"left",
	"inverted",
	"right",
	"\n"};

static const char *reflections[5] = {
	"normal",
	"x",
	"y",
	"xy",
	"\n"};

/* subpixel order */
static const char *order[6] = {
	"unknown",
	"horizontal rgb",
	"horizontal bgr",
	"vertical rgb",
	"vertical bgr",
	"no subpixels"};

static const struct {
	const char *string;
	unsigned long flag;
}mode_flags[] = {
	{	"+HSync", RR_HSyncPositive},
	{	"-HSync", RR_HSyncNegative},
	{	"+VSync", RR_VSyncPositive},
	{	"-VSync", RR_VSyncNegative},
	{	"Interlace", RR_Interlace},
	{	"DoubleScan", RR_DoubleScan},
	{	"CSync", RR_CSync},
	{	"+CSync", RR_CSyncPositive},
	{	"-CSync", RR_CSyncNegative},
	{	NULL, 0}
};

/* v refresh frequency in Hz */
double mode_refresh (X11::XRRModeInfo *mode_info)
{
	double rate;

	if (mode_info->hTotal && mode_info->vTotal)
	rate = ((double) mode_info->dotClock /
			((double) mode_info->hTotal * (double) mode_info->vTotal));
	else
	rate = 0;
	return rate;
}

/* h sync frequency in Hz */
double mode_hsync (X11::XRRModeInfo *mode_info)
{
	double rate;

	if (mode_info->hTotal)
	rate = (double) mode_info->dotClock / (double) mode_info->hTotal;
	else
	rate = 0;
	return rate;
}

char *manufacturer_name(unsigned char *x)
{
    static char name[4];

    name[0] = ((x[0] & 0x7C) >> 2) + '@';
    name[1] = ((x[0] & 0x03) << 3) + ((x[1] & 0xE0) >> 5) + '@';
    name[2] = (x[1] & 0x1F) + '@';
    name[3] = 0;

    return name;
}

</%shared><%cpp>
reply.setHeader ("Cache-Control", "no-cache", true);
reply.setContentType("application/json; charset=utf-8");

HDF *hdf = NULL;
NEOERR *err;

string dualhead_enabled = "";
string graphtft_enabled = "";
string deinterlacer_hd = "bob";
string deinterlacer_sd = "temporal";
string devmode = "0";

Json::Value json;

//get current lirc settings from database
if (((err = hdf_init(&hdf)) != STATUS_OK) || ((err = hdf_read_file(hdf, YAVDRDB)) != STATUS_OK))
{
	nerr_log_error(err);
}
else
{
	dualhead_enabled = hdf_get_value(hdf, "system.x11.dualhead.enabled", "0");
	if (dualhead_enabled == "") {
		dualhead_enabled = "0";
	}
	graphtft_enabled = hdf_get_value(hdf, "vdr.plugin.graphtft.enabled", "0");
	if (graphtft_enabled == "") {
		graphtft_enabled = "0";
	}
	deinterlacer_hd = hdf_get_value(hdf, "vdr.deinterlacer.hd.type", "bob");
	if (deinterlacer_hd == "") {
		deinterlacer_hd = "bob";
	}
	deinterlacer_sd = hdf_get_value(hdf, "vdr.deinterlacer.sd.type", "temporal");
	if (deinterlacer_hd == "") {
		deinterlacer_hd = "temporal";
	}
	devmode = hdf_get_value(hdf, "webfrontend.devmode", "0");

	json["system"]["x11"]["dualhead"]["enabled"] = dualhead_enabled;

	Bool ret;
	//int screen, display_devices, enabled_devices, screen_devices, mask, len, j;
	char *str, *start;
	string _s;
	int nDisplayDevice = 0;

	int event_base, error_base;
	int major, minor;

	bool has_1_2, has_1_3;

	/*
	 * Open a display connection, and make sure the NV-CONTROL X
	 * extension is present on the screen we want to use.
	 */
	X11::Display *dpy = X11::XOpenDisplay((display == ""?NULL:display.c_str()));

	if (dpy) {
		int screen = (((X11::_XPrivDisplay)dpy)->default_screen);
		X11::Window root = (((dpy)->screens[(screen)]).root);

		if (X11::XRRQueryExtension (dpy, &event_base, &error_base) &&
				X11::XRRQueryVersion (dpy, &major, &minor))
		{
			if (major > 1 || (major == 1 && minor >= 2)) {
				has_1_2 = true;
				json["system"]["x11"]["has_1_2"] = true;
			}
			if (major > 1 || (major == 1 && minor >= 3)) {
				has_1_3 = true;
				json["system"]["x11"]["has_1_3"] = true;
			}
			if (has_1_2) {
				int minWidth, maxWidth, minHeight, maxHeight;
				Json::Value displays;
				int next;

				//displays["ids"] = new Json::Value();
				// get_screen
				X11::XRRGetScreenSizeRange (dpy, root, &minWidth, &minHeight,
						&maxWidth, &maxHeight);
				X11::XRRScreenResources *res = X11::XRRGetScreenResourcesCurrent (dpy, root);

				if (res) {
					// get_crtcs
					int c, num_crtcs = res->ncrtc;

					//for (c = 0; c < res->ncrtc; c++)
					//{
					/*						X11::XRRCrtcInfo *crtc_info = X11::XRRGetCrtcInfo (dpy, res, res->crtcs[c]);
					 if (crtc_info->mode == None) {
					 continue;
					 }

					 X11::XRRCrtcTransformAttributes *attr;
					 X11::XRRPanning *panning_info = NULL;

					 if (has_1_3) {
					 X11::XRRPanning zero;
					 memset(&zero, 0, sizeof(zero));
					 panning_info = X11::XRRGetPanning (dpy, res, res->crtcs[c]);
					 zero.timestamp = panning_info->timestamp;
					 if (!memcmp(panning_info, &zero, sizeof(zero))) {
					 Xfree(panning_info);
					 panning_info = NULL;
					 }
					 }
					 */
					// get outputs
					for (int o = 0; o < res->noutput; o++)
					{
						X11::XRROutputInfo *output_info = X11::XRRGetOutputInfo (dpy, res, res->outputs[o]);

						//int id = output_info->mode;

						if (!output_info) {
							log_error ("could not get output 0x" << res->outputs[o] << " information\n");
							continue;
						}

						displays[nDisplayDevice]["primary"] = (screen == 0);
						displays[nDisplayDevice]["secondary"] = (screen == 1);
						displays[nDisplayDevice]["screen"] = screen;
						displays[nDisplayDevice]["devicename"] = output_info->name;
						displays[nDisplayDevice]["connected"] = connection[output_info->connection];

						//log_debug (output_info->name << " " << connection[output_info->connection] << "\n");

						Json::Value modelines, known;
						next = 0;
						for (int j = 0; j < output_info->nmode; j++)
						{
							unsigned id = output_info->modes[j];

							for (int m = 0; m < res->nmode; m++)
							{
								X11::XRRModeInfo *mode = &res->modes[m];
								if (id == mode->id) {
									switch (output_info->connection) {
										case RR_Connected:
										case RR_UnknownConnection:
										{
											int pos;
											if (!known.isMember(mode->name)) {
												known[mode->name] = next;
												pos = next++;
												modelines[pos]["id"] = mode->name;
												modelines[next]["width"] = mode->width;
												modelines[next]["height"] = mode->height;
											} else {
												pos = known[mode->name].asInt();
											}

											Json::Value modeline;
											modeline["interlace"] = (bool)(mode->modeFlags & mode_flags[4].flag);
											modeline["doublescan"] = (bool)(mode->modeFlags & mode_flags[5].flag);

											modeline["clock"][0] = (float)mode->dotClock / 1000000.0;
											modeline["clock"][1] = mode->width;
											modeline["clock"][2] = mode->hSyncStart;
											modeline["clock"][3] = mode->hSyncEnd;
											modeline["clock"][4] = mode->hTotal;
											modeline["clock"][5] = mode->height;
											modeline["clock"][6] = mode->vSyncStart;
											modeline["clock"][7] = mode->vSyncEnd;
											modeline["clock"][8] = mode->vTotal;

											string sModeline = format("%.2f %i %i %i %i %i %i %i",
													(float)mode->dotClock / 1000000.0,
													mode->width, mode->hSyncStart, mode->hSyncEnd, mode->hTotal,
													mode->height, mode->vSyncStart, mode->vSyncEnd, mode->vTotal);

											for (int f = 0; mode_flags[f].flag; f++) {
												if (mode->modeFlags & mode_flags[f].flag) {
													sModeline += format(" %s", mode_flags[f].string);
												}
											}
											modeline["modeline"] = sModeline;
											modeline["hz"] = (int)floor(0.5 + mode_refresh(mode));

											string key = format("%.0f", mode_refresh(mode))
											+ (mode->modeFlags & mode_flags[4].flag?"i":"")
											+ (mode->modeFlags & mode_flags[5].flag?"d":"");

											modeline["id"] = string(mode->name) + "_" + key;

											if ((mode->name[0] == 'V' &&
															mode->name[1] == 'G' &&
															mode->name[2] == 'A' /*&& name == displayDeviceName*/) || devmode == "1") {
												Json::Value modeline;
												modeline["id"] = "VGA2Scart_16_9";
												modeline["modeline"] = "19 1024 1032 1120 1216 576 581 586 625 -Hsync -Vsync interlace";
												modeline["x"] = 1024;
												modeline["y"] = 576;
												modeline["clock"][0u] = 19;
												modeline["clock"][1u] = 1024;
												modeline["clock"][2u] = 1032;
												modeline["clock"][3u] = 1120;
												modeline["clock"][4u] = 1216;
												modeline["clock"][5u] = 576;
												modeline["clock"][6u] = 581;
												modeline["clock"][7u] = 586;
												modeline["clock"][8u] = 625;
												modeline["interlace"] = true;
												modeline["doublescan"] = false;
												modeline["hz"] = 25;

												modelines[next]["id"] = "VGA2Scart_16_9";
												modelines[next]["modes"]["50i"] = modeline;

												next++;
												modeline["id"] = "VGA2Scart_4_3";
												modeline["modeline"] = "13.875 720 744 808 888 576 580 585 625 -HSync -Vsync interlace";
												modeline["x"] = 720;
												modeline["y"] = 576;
												modeline["clock"][0u] = 13.875;
												modeline["clock"][1u] = 720;
												modeline["clock"][2u] = 744;
												modeline["clock"][3u] = 808;
												modeline["clock"][4u] = 888;
												modeline["clock"][5u] = 576;
												modeline["clock"][6u] = 580;
												modeline["clock"][7u] = 586;
												modeline["clock"][8u] = 625;
												modeline["interlace"] = true;
												modeline["doublescan"] = false;
												modeline["hz"] = 25;

												modelines[next]["id"] = "VGA2Scart_4_3";
												modelines[next]["modes"]["50i"] = modeline;
											}
											modelines[pos]["modes"][key] = modeline;

											for (c = 0; c < res->ncrtc; c++)
											{
												X11::XRRCrtcInfo *crtc_info = X11::XRRGetCrtcInfo (dpy, res, res->crtcs[c]);
												if (crtc_info->mode == None) {
													continue;
												}
												if (id == crtc_info->mode) {
													displays[nDisplayDevice]["current"]["id"] = mode->name;
													displays[nDisplayDevice]["current"]["freq"] = key;
													// get selected modlines...
													int l = 0;
													char *mode = NULL;
													do {
														mode = hdf_get_valuef(hdf, "system.x11.display.%u.mode.%u", nDisplayDevice, l);
														if (mode != NULL) {
															displays[nDisplayDevice]["current"]["selected"][l++] = mode;
														}
													}while (mode != NULL);
													char *defaultfreq = hdf_get_valuef(hdf, "system.x11.display.%u.default", nDisplayDevice);
													if (defaultfreq != NULL)
													{
														displays[nDisplayDevice]["defaultfreq"] = defaultfreq;

													}
													else
													{
														displays[nDisplayDevice]["defaultfreq"] = false;
													}

													displays[nDisplayDevice]["width"] = crtc_info->width;
													displays[nDisplayDevice]["height"] = crtc_info->height;
													displays[nDisplayDevice]["x"] = crtc_info->x;
													displays[nDisplayDevice]["y"] = crtc_info->y;

													displays[nDisplayDevice]["geometry"] = format("%dx%d+%d+%d",
															crtc_info->width, crtc_info->height,
															crtc_info->x, crtc_info->y);

													X11::XRRCrtcTransformAttributes *attr;
													X11::XRRPanning *panning_info = NULL;

													if (has_1_3) {
														X11::XRRPanning zero;
														memset(&zero, 0, sizeof(zero));
														panning_info = X11::XRRGetPanning (dpy, res, res->crtcs[c]);
														zero.timestamp = panning_info->timestamp;
														if (!memcmp(panning_info, &zero, sizeof(zero))) {
															Xfree(panning_info);
															panning_info = NULL;
														}
													}

													char *overscan = hdf_get_valuef(hdf, "system.x11.display.%u.viewport.in.x", nDisplayDevice);
													if (overscan != NULL)
													{
														displays[nDisplayDevice]["viewport"]["in"]["x"] = atoi(overscan);
														overscan = hdf_get_valuef(hdf, "system.x11.display.%u.viewport.in.y", nDisplayDevice);
														displays[nDisplayDevice]["viewport"]["in"]["y"] = atoi(overscan);;
													}
													else
													{
														displays[nDisplayDevice]["viewport"]["in"]["width"] = crtc_info->width;
														displays[nDisplayDevice]["viewport"]["in"]["height"] = crtc_info->height;
													}
													overscan = hdf_get_valuef(hdf, "system.x11.display.%u.viewport.out.x", nDisplayDevice);
													if (overscan != NULL)
													{
														displays[nDisplayDevice]["viewport"]["out"]["x"] = atoi(overscan);;
														overscan = hdf_get_valuef(hdf, "system.x11.display.%u.viewport.out.y", nDisplayDevice);
														displays[nDisplayDevice]["viewport"]["out"]["y"] = atoi(overscan);;
													}
													else
													{
														displays[nDisplayDevice]["viewport"]["out"]["width"] = crtc_info->width;
														displays[nDisplayDevice]["viewport"]["out"]["height"] = crtc_info->height;
													}
													overscan = hdf_get_valuef(hdf, "system.x11.display.%u.viewport.out.plusx", nDisplayDevice);
													if (overscan != NULL)
													{
														displays[nDisplayDevice]["viewport"]["out"]["x"] = atoi(overscan);;
														overscan = hdf_get_valuef(hdf, "system.x11.display.%u.viewport.out.plusy", nDisplayDevice);
														displays[nDisplayDevice]["viewport"]["out"]["y"] = atoi(overscan);;
													}
													else
													{
														displays[nDisplayDevice]["viewport"]["out"]["x"] = 0;
														displays[nDisplayDevice]["viewport"]["out"]["y"] = 0;
													}
												}
											}

											if (j < output_info->npreferred) {
												displays[nDisplayDevice]["preferred"]["freq"] = key;
												displays[nDisplayDevice]["preferred"]["id"] = mode->name;

												if (!displays[nDisplayDevice].isMember("defaultfreq") || displays[nDisplayDevice]["defaultfreq"].isBool())
												displays[nDisplayDevice]["defaultfreq"] = string(mode->name) + "_" + key;
											}

										}
										break;
										case RR_Disconnected:
										{
											modelines.clear();
											modelines[0]["id"] = "disabled";
											modelines[0]["modes"]["0"]["modeline"] = "";
											modelines[0]["modes"]["0"]["x"] = 0;
											modelines[0]["modes"]["0"]["y"] = 0;
											modelines[0]["modes"]["0"]["interlace"] = false;
											modelines[0]["modes"]["0"]["doublescan"] = false;
										}
										break;
									}
								}
							}
						}
						displays[nDisplayDevice]["modelines"] = modelines;

						int nprop;
						bool manufacturerFound = false;
						X11::Atom *props = X11::XRRListOutputProperties (dpy, res->outputs[o], &nprop);
						for (int j = 0; j < nprop; j++) {
							unsigned char *prop;
							int actual_format;
							unsigned long nitems, bytes_after;
							X11::Atom actual_type;
							X11::XRRPropertyInfo *propinfo;

							X11::XRRGetOutputProperty (dpy, res->outputs[o], props[j],
									0, 100, False, False,
									AnyPropertyType,
									&actual_type, &actual_format,
									&nitems, &bytes_after, &prop);

							propinfo = X11::XRRQueryOutputProperty(dpy, res->outputs[o], props[j]);

							if (actual_type == ((X11::Atom) 19) && actual_format == 8) {
								int k;
								char *name = X11::XGetAtomName (dpy, props[j]);
								if (name[0] == 'E' &&
										name[1] == 'D' &&
										name[2] == 'I' &&
										name[3] == 'D') {
									manufacturerFound = true;
									displays[nDisplayDevice]["name"] = manufacturer_name(prop + 0x08);
								}
							}

							free(propinfo);
						}
						
						if (!manufacturerFound) {
							displays[nDisplayDevice]["name"] = output_info->name;
						}

						nDisplayDevice++;
					}
				}

				json["system"]["x11"]["displays"] = displays;
			}
			else
			{
				log_error("The XRandr extension V 1.2 and above is needed\n\n");
			}

			XCloseDisplay(dpy);

		}
		else
		{
			log_error("Cannot open display '" << X11::XDisplayName(NULL) << "'.\n\n");
		}

		json["vdr"]["plugin"]["graphtft"]["enabled"] = graphtft_enabled;
		json["vdr"]["deinterlacer"]["hd"]["type"] = deinterlacer_hd;
		json["vdr"]["deinterlacer"]["sd"]["type"] = deinterlacer_sd;

	}
}
reply.out() << json;

</%cpp>
